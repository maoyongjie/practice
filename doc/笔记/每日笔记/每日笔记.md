# 每日笔记

# 1.ES条件删除

**2022-03-17**

```java
	/**
     * 条件删除
     */
    public static long deleteQuery() {
        RestHighLevelClient client = getClient();
        //参数为索引名，可以不指定，可以一个，可以多个
        DeleteByQueryRequest request = new DeleteByQueryRequest("hockey");
        // 更新时版本冲突
        request.setConflicts("proceed");
        // 设置查询条件，第一个参数是字段名，第二个参数是字段的值
        request.setQuery(new TermQueryBuilder("first", "sam"));
        // 更新最大文档数
        request.setSize(10);
        // 批次大小
        request.setBatchSize(1000);
        // 并行
        request.setSlices(2);
        // 使用滚动参数来控制“搜索上下文”存活的时间
        request.setScroll(TimeValue.timeValueMinutes(10));
        // 超时
        request.setTimeout(TimeValue.timeValueMinutes(2));
        // 刷新索引
        request.setRefresh(true);
        try {
            BulkByScrollResponse response = client.deleteByQuery(request, RequestOptions.DEFAULT);
            return response.getStatus().getUpdated();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return -1;
    }
```

# 2.ES聚合查询

### 2.1 Value Count Aggregation计数存在该字段的记录

```java
ValueCountAggregationBuilder count = AggregationBuilders.count("ErrorTimeCount").field("ErrorTime");

ParsedValueCount bucket = response.getAggregations().get("ErrorTimeCount");
long count = bucket.getValue(); //计数
```

### 2.2 脚本查询组合字段重复查询

```java
TermsAggregationBuilder callTypeTeamAgg = AggregationBuilders
                .terms("compositeQuery")
                .script(aggregateScript(filedList))
                .minDocCount(2);  

private Script aggregateScript(List<String> list) {
        StringBuilder sc = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            sc.append(StrUtil.format("doc['{}'].value", list.get(i)));
            if (i != list.size() - 1) {
                sc.append("+'-split-'+");
            }
        }
        return new Script(INLINE, Script.DEFAULT_SCRIPT_LANG, sc.toString(), new HashMap<>(1));
    }
```

### 2.3 Avg Aggregation与Missing字段

统计 exams 索引中考试的平均分数，如未存在分数，默认为 60 分，查询语句如下：

```json
GET /exams/_search?size=0
{
  "aggs" : {
    "avg_grade" : { 
      "avg" : { 
        "field" : "grade",
        "missing": 60
      } 
    }
  }
}
```

**如果指定字段没有值，可以通过 missing 指定默认值；若未指定默认值，缺失该字段值的文档将被忽略（计算）**。

### 2.4 Cardinality Aggregation 去重计数

Cardinality Aggregation 用于基数统计，其作用是先执行类似 SQL 中的 distinct 操作，去掉集合中的重复项，然后统计排重后的集合长度。

**假设 title 字段为文本类型（text），去重时需要指定 keyword，表示把 title 作为整体去重，即不分词统计**。

例如，在 books 索引中对 language 字段进行 cardinality 操作可以统计出编程语言的种类数，查询语句如下：

```json
GET /books/_search?size=0
{
  "aggs" : {
    "all_lan" : { 
      "cardinality" : { "field" : "language" } 
    },
    "title_cnt" : { 
      "cardinality" : { "field" : "title.keyword" } 
    }
  }
}
```

### 2.5 桶排序

按取值范围分桶

```java
RangeAggregationBuilder rangeAgg = AggregationBuilders.range("PushCount").field("VPPPushCount")
                .addRange("bucket1", 0, 11).addUnboundedFrom("bucket2", 11);
//获取桶列表
ParsedRange range = bucket.getAggregations().get("PushCount");
Long count = range.getBuckets().get(0).getDocCount();
```



# 3. kafka消费



# 4. ES集群概念

#### （1）、ES基本概念名词

　　　　Cluster

 　代表一个集群，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。

 　　　Shards

　　代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。

 　　　replicas

　　代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。

 　　　Recovery

　　代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。

　　**（2）、ES为什么要实现集群**

　　在单台ES服务器节点上，随着业务量的发展索引文件慢慢增多，会影响到效率和内存存储问题等。

　　我们可以采用ES集群，将单个索引的分片到多个不同分布式物理机器上存储，从而可以实现高可用、容错性等。

　　ES集群中索引可能由多个分片构成，并且每个分片可以拥有多个副本。通过将一个单独的索引分为多个分片，我们可以处理不能在一个单一的服务器上面运行的大型索引，简单的说就是索引的大小过大，导致效率问题。不能运行的原因可能是内存也可能是存储。由于每个分片可以有多个副本，通过将副本分配到多个服务器，可以提高查询的负载能力。
